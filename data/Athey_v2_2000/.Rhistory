plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
# plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120))  # second
# plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
# plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120), add=T)  # second
x1 = rnorm(1000,mean = 50, sd = 5)
h1 <- hist(x1, breaks=100, plot=FALSE)
x2 = rnorm(1000,mean = 55, sd = 10)
h2 <- hist(x2, breaks=100, plot=FALSE)
# plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120))  # second
# plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
# plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120), add=T)  # second
x1 = rnorm(1000,mean = 50, sd = 5)
h1 <- hist(x1, breaks=100, plot=FALSE)
x2 = rnorm(1000,mean = 55, sd = 10)
h2 <- hist(x2, breaks=100, plot=FALSE)
# plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
# plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120))  # second
plot( h1, col=rgb(0,0,1,1/4), xlim=c(0,120))  # first histogram
plot( h2, col=rgb(1,0,0,1/4), xlim=c(0,120), add=T)  # second
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE )
library(kableExtra)
library(png)
library(ggplot2)
library(reshape2)
library(egg)
require(tidyr)
require(dplyr)
library(dplyr)
library(latex2exp)
# library(ggpubr)
library(data.table)
library(RColorBrewer)
library(MASS)
require(scales)
rm(list=ls())
setwd("/Users/sina/Desktop/FlowOCT-ManagementScience2020/Results/")
data_train= read.csv('train.csv', header=TRUE, sep=',', na.strings="", stringsAsFactors =TRUE)
data_test= read.csv('test.csv', header=TRUE, sep=',', na.strings="", stringsAsFactors =TRUE)
forpres=FALSE
if (forpres){
fontfam = "sans"
} else {
fontfam = "serif"
}
figure_path = "/Users/sina/Desktop/FlowOCT-ManagementScience2020/Figures/"
data_train$sample <- as.factor(data_train$sample)
data_train$depth <- as.factor(data_train$depth)
data_test$sample <- as.factor(data_test$sample)
data_test$depth <- as.factor(data_test$depth)
tmp <- subset(data_train, data_train$regularization == FALSE &  data_train$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BinOCT","3600",max(subset(tmp, tmp$Approach=="BinOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT", "BinOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[4], brewer.pal(4, 'Set1')[1] ) #c("firebrick1 == 1","violetred==4","seagreen4==3","royalblue==2")
shapes <- c(15,16,17,4)
g1 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(text = element_text(size=14,family=fontfam))
print(g1)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_no_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_no_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == TRUE)
tmp$approach <- droplevels(tmp$approach)
tmp <- subset(tmp, tmp$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[1], brewer.pal(4, 'Set1')[4] )
shapes <- c(15,16,4,17)
#c("firebrick1","violetred","seagreen4","royalblue")(1,3,2,4)
g2 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "right", text = element_text(size=14,family=fontfam))
print(g2)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == TRUE)
tmp$approach <- droplevels(tmp$approach)
tmp <- subset(tmp, tmp$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[1], brewer.pal(4, 'Set1')[4] )
shapes <- c(15,16,4,17)
#c("firebrick1","violetred","seagreen4","royalblue")(1,3,2,4)
g2 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "bottom", text = element_text(size=14,family=fontfam))
print(g2)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == TRUE)
tmp$approach <- droplevels(tmp$approach)
tmp <- subset(tmp, tmp$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[1], brewer.pal(4, 'Set1')[4] )
shapes <- c(15,16,4,17)
#c("firebrick1","violetred","seagreen4","royalblue")(1,3,2,4)
g2 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "right", text = element_text(size=14,family=fontfam))
print(g2)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == FALSE &  data_train$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BinOCT","3600",max(subset(tmp, tmp$Approach=="BinOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT", "BinOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[4], brewer.pal(4, 'Set1')[1] ) #c("firebrick1 == 1","violetred==4","seagreen4==3","royalblue==2")
shapes <- c(15,16,17,4)
g1 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "right",text = element_text(size=14,family=fontfam))
print(g1)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_no_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_no_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == FALSE &  data_train$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BinOCT","3600",max(subset(tmp, tmp$Approach=="BinOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT", "BinOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[4], brewer.pal(4, 'Set1')[1] ) #c("firebrick1 == 1","violetred==4","seagreen4==3","royalblue==2")
shapes <- c(15,16,17,4)
g1 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "bottom",text = element_text(size=14,family=fontfam))
print(g1)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_no_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_no_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == FALSE &  data_train$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BinOCT","3600",max(subset(tmp, tmp$Approach=="BinOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT", "BinOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[4], brewer.pal(4, 'Set1')[1] ) #c("firebrick1 == 1","violetred==4","seagreen4==3","royalblue==2")
shapes <- c(15,16,17,4)
g1 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "bottom",text = element_text(size=14,family=fontfam))
print(g1)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_no_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5.5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_no_regularization.pdf",sep = ""),device = "pdf", width = 5.5, height = 3.3, units =  "in")
}
tmp <- subset(data_train, data_train$regularization == FALSE &  data_train$status %in% c(2,101,102))
tmp <- tmp[order(tmp$solving_time),]
tmp$numOfInstances <- rowidv(tmp, cols="approach")
tmp <- tmp[,c("approach","solving_time","numOfInstances")]
names(tmp) <- c("Approach","solving_time","numOfInstances")
tmp[nrow(tmp) + 1,] = list("OCT","3600",max(subset(tmp, tmp$Approach=="OCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BinOCT","3600",max(subset(tmp, tmp$Approach=="BinOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("FlowOCT","3600",max(subset(tmp, tmp$Approach=="FlowOCT")$numOfInstances))
tmp[nrow(tmp) + 1,] = list("BendersOCT","3600",max(subset(tmp, tmp$Approach=="BendersOCT")$numOfInstances))
tmp$solving_time <- as.numeric(as.character(tmp$solving_time))
tmp$numOfInstances <- as.numeric(as.character(tmp$numOfInstances))
tmp$Approach  <- factor(tmp$Approach , levels = c("BendersOCT", "FlowOCT", "BinOCT","OCT"))
tmp <- tmp[order(tmp$Approach),]
colors <- c( brewer.pal(4, 'Set1')[3], brewer.pal(4, 'Set1')[2], brewer.pal(4, 'Set1')[4], brewer.pal(4, 'Set1')[1] ) #c("firebrick1 == 1","violetred==4","seagreen4==3","royalblue==2")
shapes <- c(15,16,17,4)
g1 <- ggplot(data = tmp, aes(x=solving_time, y=numOfInstances, group=Approach,color=Approach)) +
geom_line(size=0.5)+ #aes(linetype=Approach)
geom_point(aes(shape=Approach),size=2)+
labs(x="Time (s)", y = "Number of Instances Solved")+
scale_color_manual(values=colors)+
scale_shape_manual(values=shapes)+
theme(legend.position = "right",text = element_text(size=14,family=fontfam))
print(g1)
if (forpres)
{
ggsave(paste(figure_path,"class_perf_opt_no_regularization_presentation.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
} else {
ggsave(paste(figure_path,"class_perf_opt_no_regularization.pdf",sep = ""),device = "pdf", width = 5, height = 3.3, units =  "in")
}
rm(list=ls())
graphics.off()
setwd("/Users/sina/Documents/GitHub/prescriptive-trees/data/Athey_v2/")
##########################################################################################################
# Parameters
##########################################################################################################
# Choose the seeds
seeds = c(123,156,67,1,43)
N_train_set = c(2000,2000,2000,2000,2000)
Run = 5
set.seed(seeds[Run])
threshold = 0.5
N_training = N_train_set[Run]
N_test = 10000
N  = N_training + N_test
d = 3 #dimension of the data
##########################################################################################################
# Functions
##########################################################################################################
baseline <- function (x) {
x = as.numeric(x)
alpha_1 = 1/2
alpha_2 = 1/2
alpha_3 = 1
value =  alpha_1*x[1] + alpha_2*x[2] + alpha_3*x[3]
value
}
effect <- function (x) {
x = as.numeric(x)
alpha_4 = 0.5
alpha_5 = 0.5
value =  alpha_4 * x[1] + alpha_5 * x[2]
value
}
scalefunc <- function(x){
y0_min_val = min(x$y0)
y0_max_val = max(x$y0)
x$y0 <- (x$y0 - y0_min_val)/(y0_max_val-y0_min_val)
y1_min_val = min(x$y1)
y1_max_val = max(x$y1)
x$y1 <- (x$y1 - y1_min_val)/(y1_max_val-y1_min_val)
x
}
##########################################################################################################
# Generating the data
##########################################################################################################
#Generating odd and even columns from normal and bernoulli distribution respectiveley
mat <- matrix(data = rbinom((N)*d, size=1, prob=0.5), nrow = N, ncol = d)*2 - 1
data <- as.data.frame(mat)
rm(mat)
#Generating the true outcomes under treatment zero and one
data$y0  =  apply(data, 1, function(x) baseline(x) - 0.5* effect(x) )
data$y1  =  apply(data, 1, function(x) baseline(x) + 0.5* effect(x) )
###########################################################
# Genreating the treatment each person receives
###########################################################
# Finding the best possible treatment for each person
data$best_treatment <- 1
index <- data$y0 > data$y1
data$best_treatment[index] <- 0
# if prob_best <= threshold then that person would receive the best treatment
data$prob_best <- runif(n=N,min=0,max=1)
data$threshold <- threshold
# assigning the treatment using prob_best and best_treatment
data$t =  1 - data$best_treatment
index <- data$prob_best <= threshold
data$t[index] =  data$best_treatment[index]
###########################################################
# generating the true prob_t P(t|x)
###########################################################
data$prob_t = (1-abs(data$best_treatment - data$t))*threshold + abs(data$best_treatment - data$t)*(1-threshold)
data$best_treatment <- NULL
data$prob_best <- NULL
data$threshold <- NULL
##########################################################################################################
# Adding the noise to the  data
##########################################################################################################
# Adding noise to the data y0 and y1
data$y0= data$y0 + rnorm(N,mean = 0 , sd = 0.1)
data$y1 = data$y1 + rnorm(N,mean = 0 , sd = 0.1)
# cat("Let's see how often treatment is a better choice")
# nrow(subset(data, data$y1 > data$y0))/nrow(data)*100
#
# cat("Let's see how often treatment is a worse choice")
# nrow(subset(data, data$y1 < data$y0))/nrow(data)*100
#
# cat("Let's see how often both result in the same outcome")
# nrow(subset(data, data$y1 == data$y0))/nrow(data)*100
##########################################################################################################
# Splitting data into training and test and save the files
##########################################################################################################
# Splitting training and test data
data_train = data[1:N_training,]
data_test = data[(N_training+1):N,]
##########################################################################################################
# Scaling y0 and y1 to [0,1]
##########################################################################################################
data_train <- scalefunc(data_train)
data_test <- scalefunc(data_test)
##########################################################################################################
# Generating the outcome column y
##########################################################################################################
data_train$y = data_train$t*data_train$y1 + (1-data_train$t)*data_train$y0
data_test$y = data_test$t*data_test$y1 + (1-data_test$t)*data_test$y0
# Some minor steps
data_train$t <- as.factor(as.character(data_train$t))
data_test$t <- as.factor(as.character(data_test$t))
View(data_train)
# library(data.table)
# library(Publish)
# library(caret)
# library(sigmoid)
rm(list=ls())
graphics.off()
setwd("/Users/sina/Documents/GitHub/prescriptive-trees/data/Athey_v2/")
##########################################################################################################
# Parameters
##########################################################################################################
# Choose the seeds
seeds = c(123,156,67,1,43)
N_train_set = c(2000,2000,2000,2000,2000)
Run = 5
set.seed(seeds[Run])
threshold = 0.9
N_training = N_train_set[Run]
N_test = 10000
N  = N_training + N_test
d = 3 #dimension of the data
##########################################################################################################
# Functions
##########################################################################################################
baseline <- function (x) {
x = as.numeric(x)
alpha_1 = 1/2
alpha_2 = 1/2
alpha_3 = 1
value =  alpha_1*x[1] + alpha_2*x[2] + alpha_3*x[3]
value
}
effect <- function (x) {
x = as.numeric(x)
alpha_4 = 0.5
alpha_5 = 0.5
value =  alpha_4 * x[1] + alpha_5 * x[2]
value
}
scalefunc <- function(x){
y0_min_val = min(x$y0)
y0_max_val = max(x$y0)
x$y0 <- (x$y0 - y0_min_val)/(y0_max_val-y0_min_val)
y1_min_val = min(x$y1)
y1_max_val = max(x$y1)
x$y1 <- (x$y1 - y1_min_val)/(y1_max_val-y1_min_val)
x
}
##########################################################################################################
# Generating the data
##########################################################################################################
#Generating odd and even columns from normal and bernoulli distribution respectiveley
mat <- matrix(data = rbinom((N)*d, size=1, prob=0.5), nrow = N, ncol = d)*2 - 1
data <- as.data.frame(mat)
rm(mat)
#Generating the true outcomes under treatment zero and one
data$y0  =  apply(data, 1, function(x) baseline(x) - 0.5* effect(x) )
data$y1  =  apply(data, 1, function(x) baseline(x) + 0.5* effect(x) )
###########################################################
# Genreating the treatment each person receives
###########################################################
# Finding the best possible treatment for each person
data$best_treatment <- 1
index <- data$y0 > data$y1
data$best_treatment[index] <- 0
# if prob_best <= threshold then that person would receive the best treatment
data$prob_best <- runif(n=N,min=0,max=1)
data$threshold <- threshold
# assigning the treatment using prob_best and best_treatment
data$t =  1 - data$best_treatment
index <- data$prob_best <= threshold
data$t[index] =  data$best_treatment[index]
###########################################################
# generating the true prob_t P(t|x)
###########################################################
data$prob_t = (1-abs(data$best_treatment - data$t))*threshold + abs(data$best_treatment - data$t)*(1-threshold)
data$best_treatment <- NULL
data$prob_best <- NULL
data$threshold <- NULL
##########################################################################################################
# Adding the noise to the  data
##########################################################################################################
# Adding noise to the data y0 and y1
data$y0= data$y0 + rnorm(N,mean = 0 , sd = 0.1)
data$y1 = data$y1 + rnorm(N,mean = 0 , sd = 0.1)
# cat("Let's see how often treatment is a better choice")
# nrow(subset(data, data$y1 > data$y0))/nrow(data)*100
#
# cat("Let's see how often treatment is a worse choice")
# nrow(subset(data, data$y1 < data$y0))/nrow(data)*100
#
# cat("Let's see how often both result in the same outcome")
# nrow(subset(data, data$y1 == data$y0))/nrow(data)*100
##########################################################################################################
# Splitting data into training and test and save the files
##########################################################################################################
# Splitting training and test data
data_train = data[1:N_training,]
data_test = data[(N_training+1):N,]
##########################################################################################################
# Scaling y0 and y1 to [0,1]
##########################################################################################################
data_train <- scalefunc(data_train)
data_test <- scalefunc(data_test)
##########################################################################################################
# Generating the outcome column y
##########################################################################################################
data_train$y = data_train$t*data_train$y1 + (1-data_train$t)*data_train$y0
data_test$y = data_test$t*data_test$y1 + (1-data_test$t)*data_test$y0
# Some minor steps
data_train$t <- as.factor(as.character(data_train$t))
data_test$t <- as.factor(as.character(data_test$t))
View(data_train)
t_train_data = data_train[,!(names(data_train) %in% c("y0","y1","y","prop_score_t"))]
t_test_data = data_test[,!(names(data_test) %in% c("y0","y1","y","prop_score_t"))]
glm.fit <- glm(t ~ ., data = t_train_data, family = "binomial")
summary(glm.fit)
